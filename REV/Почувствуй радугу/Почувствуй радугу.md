## Overview
Больше хешей – надежнее. Или нет?

---
## Анализ кода

### 1. Точка входа

В `_start` вызывается обычный `__libc_start_main(main, ...)` — всё стандартно. Настоящая логика в `main`.
### 2. Что делает `main`

В `main` мы видим большой кусок кода, который создаёт **24 (`0x18`) строк** вида:
`9d5ed678fe57bcca610140957afab571 7b774effe4a349c6dd82ad4f4f21d34c b2f5ff47436671b6e533d8dc3614845d ... cbb184dd8e05c9709e5dcaedaa0495cf`
Т.е. программа заранее забивает в память **24 MD5-хеша в виде строк**.
![rainbow](rainbow.png)
Дальше:
1. программа выводит приглашение,
2. читает строку через `std::getline`,
3. проверяет, что длина ввода **ровно 24 байта**,
4. если длина подходит, то идёт цикл:

```c
for (i = 0; i < 0x18; i++) {
    ch = input[i];
    if (check_char_md5(ch, &md5_list[i]) != 1) {
        // wrong
    }
}

```

То есть это **не** проверка одного общего MD5 от всей строки — это **24 независимых проверки**: на i-й позиции должен стоять символ, MD5 от которого совпадает с i-м хешем из списка.
Если хотя бы одна позиция не совпала — печатается “неверно”. Если все 24 совпали — “верно”.
### 3. Функция `check_char_md5`

Вот её декомпиляция (с твоего кода):

```c
ulong check_char_md5(char param_1, string *param_2)
{
  char buf[1];
  string md5str;

  buf[0] = param_1;
  calculate_md5((uchar *) &md5str, (ulong) buf);
  bool ok = (md5str == *param_2);
  md5str.~string();
  return ok;
}

```
Смысл: взять **один символ**, посчитать от него MD5 (своей же функцией), получить строку из 32 hex-символов и сравнить с переданным образцом.
То есть задача окончательно сводится к: «для каждого из 24 хешей подобрать один печатный символ».
### 4. Функция `calculate_md5`

Там много кода, но суть простая:
- инициализация стандартных MD5-констант: `0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476`
- дописывание 0x80, выравнивание по 64 байта, дописывание длины в битах — классическая MD5-схема
- вызов их же `MD5_Transform(...)`
- в конце они собирают 16 байт результата и форматируют их в строку через `sprintf("%02x", ...)`
- возвращают `std::string` с хешем
То есть это обычный MD5.

---
## Восстановление флага

Раз у нас 24 MD5-строки и мы знаем, что каждая — это MD5 от **одного символа**, достаточно перебрать все печатные ASCII и найти, какой символ даёт нужный хеш.

Пример скрипта (Python):

```python
import hashlib

hashes = [
"9d5ed678fe57bcca610140957afab571",
"7b774effe4a349c6dd82ad4f4f21d34c",
"b2f5ff47436671b6e533d8dc3614845d",
"0d61f8370cad1d412f80b84d143e1257",
"b9ece18c950afbfa6b0fdbfa4ff731d3",
"800618943025315f869e4e1f09471012",
"f95b70fdc3088560732a5ac135644506",
"4b43b0aee35624cd95b910189b3dc231",
"eccbc87e4b5ce2fe28308fd9f2a7baf3",
"9e3669d19b675bd57058fd4664205d2a",
"b14a7b8059d9c055954c92674ce60032",
"2510c39011c5be704182423e3a695e91",
"a87ff679a2f3e71d9181a67b7542122c",
"03c7c0ace395d80182db07ae2c30f034",
"2510c39011c5be704182423e3a695e91",
"b14a7b8059d9c055954c92674ce60032",
"4a8a08f09d37b73795649038408b5f33",
"4b43b0aee35624cd95b910189b3dc231",
"a87ff679a2f3e71d9181a67b7542122c",
"4a8a08f09d37b73795649038408b5f33",
"8ce4b16b22b58894aa86c421e8759df3",
"eccbc87e4b5ce2fe28308fd9f2a7baf3",
"4b43b0aee35624cd95b910189b3dc231",
"cbb184dd8e05c9709e5dcaedaa0495cf",
]

# печатные ASCII
candidates = ''.join(chr(i) for i in range(32, 127))

flag_chars = []
for h in hashes:
    for ch in candidates:
        if hashlib.md5(ch.encode()).hexdigest() == h:
            flag_chars.append(ch)
            break

flag = ''.join(flag_chars)
print(flag)

```

